<html>
	<head>
		
		<style>
			body { margin: 0; }
			canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="js/three.min.js"></script>
	    <script src="js/physijs/physi.js"></script>
		<script src="js/THREEx.KeyboardState.js"></script>
	    <script src="lib/dat.gui.min.js"></script>
		
		
		
		<script type="text/javascript">
			
			//'use strict';
			
			var plane_body;
			var directionalLight, ambientLight;
			var FizzyText, enginespeed, keyboard, clock, scene, renderer, myGui;//globals
			var thrust = 0;
			setupGui();
			var createScene = function() {
				directionalLight = new THREE.DirectionalLight(0xffffff, 0.5);
				directionalLight.position.set(0, 1, 0);
				
				ambientLight = new THREE.AmbientLight(0x040404);
				
				Physijs.scripts.worker = 'js/physijs/physijs_worker.js';
				Physijs.scripts.ammo = 'ammo.js';
				
				scene = new Physijs.Scene();
				
				scene.add(ambientLight);
				camera = new THREE.PerspectiveCamera(
				35,
				window.innerWidth / window.innerHeight,
				1,
				1000
				);
				
				camera.position.set(60, 50, 60);
				//camera.lookAt(scene.position);
				
			    scene.add(camera);
                scene.add(directionalLight);
				keyboard = new THREEx.KeyboardState();
				
				renderer = new THREE.WebGLRenderer();
			    renderer.setSize(window.innerWidth, window.innerHeight);
			    document.body.appendChild(renderer.domElement);
				
			}
			createScene();
			
			
			
			
			plane = new Physijs.BoxMesh(
			new THREE.CubeGeometry(100000, 1, 100000),
			new THREE.MeshBasicMaterial({ color: 0xffff44}),
			0//mass
			);		  
		 	
			scene.add(plane);		  
			
			
			
			
			render_plane();
			
			
			
			//plane_body.rotation.x=-60*Math.PI/180;
			//plane_body.rotation.y=-30*Math.PI/180;
			//plane_body.rotation.z=-30*Math.PI/180;
			
			
			scene.add(plane_body);
			function render(){
			    requestAnimationFrame(render);
				
				//plane_body.applyCentralForce(v3);
				//body.force.set(0, 0, enginespeed*3);
			    //fly();
				
				
				
				var drag =calculate_drag(0.03, 1.2, plane_body.getLinearVelocity(), 25);
				var lift = calculate_lift(1.0, 1.2, plane_body.getLinearVelocity().y ,25);
				var thrust = calculate_thrust(plane_body.mass);
				thrust.applyQuaternion(plane_body.quaternion);
				lift.applyQuaternion(plane_body.quaternion);
				drag.applyQuaternion(plane_body.quaternion);
				
				var net = calculate_net_force(drag, lift, thrust);
				calculate_turn();
				calculate_pitch();
				//box.applyCentralForce(drag);
				plane_body.applyCentralForce(net);
				listen(drag, lift, thrust);
				//updateCamera();
				//control();
				
				scene.simulate();
				
				renderer.render(scene, camera);
				
			}
			render();
			
			
			
			//This function calculates the drag force
			//It's parameters are 
			/*
				cd - the drag coefficient (0.02-0.04 for an airplane)
				rho - the air density (depends on altitude)
				v - velocity (this is a THREE JS Vector3)
				a - cross-sectional area 
			*/
			//returns drag as a THREE JS Vector3
			function calculate_drag(cd, rho, v, a){
			    var sac = (0.5)*(cd)*(rho)*(a);
				
				var drag = new THREE.Vector3(0, 0, 0);
				drag.setX(sac*v.x*v.x);
				drag.setY(sac*v.y*v.y);
				drag.setZ(sac*v.z*v.z);
				drag.multiplyScalar(-1);
				return drag;
			}
			
			//calculates the net force 
			//takes drag, lift, and thrust forces, and adds them together
			//gravity is included in the physics engine
			function calculate_net_force(drag, lift, thrust){
			    var net = new THREE.Vector3(0, 0, 0);
				net.add(drag).add(lift).add(thrust);
				return net;
			}
			//cl is the lift coefficient
            //rho is the air density
            //a is the area of the wings			
			function calculate_lift(cl, rho, v, a){
			    var lift_scalar = (0.5)*(cl)*(rho)*(a)*(v)*(v);
				
				var lift = new THREE.Vector3(0,0,0);
				
				lift.setZ(lift_scalar);
				
				return lift;
			}
			
			function render_plane(){
				
			    var material = new THREE.MeshLambertMaterial( { color: 0xff0000 } );
			    var sph = new THREE.MeshLambertMaterial({color: 0xf0f0f0});
				
			    var geom_body = new THREE.CylinderGeometry( 1.5, 1.05, 7, 9 );
				
			    plane_body = new Physijs.CylinderMesh( geom_body, material, 10);
				
			    var geom_top_sph = new THREE.SphereGeometry(1, 32,32);
			    var plane_top = new THREE.Mesh(geom_top_sph, sph);
				
				var geom_front_sph = new THREE.SphereGeometry(1, 32, 32);
			    var plane_front = new THREE.Mesh(geom_front_sph, sph);
			    
				
			    //plane_body.rotation.y=35*Math.PI/180;
				plane_front.position.y=3.5;
				
			    plane_top.position.z=.8
			    plane_top.position.y=1.3;
				
				//camera
				
				//camera.position.z-=10;
				
				//
			    
			    plane_body.add(plane_front);
			    plane_body.add(plane_top);
				plane_body.position.y=15;
				plane_body.rotation.x=-90*Math.PI/180;
				plane_body.add(camera);
				
				//////////////////////////////////camera pains
				
				camera.rotation.x=0;
				camera.rotation.y=0;
				
				
				camera.position.y=-15;
			    camera.position.x=0;
				camera.position.z=10;
				camera.rotation.x=70*Math.PI/180;
			    
				
				//////////////
				
				//an object3d will nullify physics engine
				
				//results in up is z+
				//right is x+
				//forward is y+
				
			    
			}
			function calculate_thrust(m){
				
				if ( keyboard.pressed("V") )
		        thrust =0;
				if ( keyboard.pressed("B") )
				thrust = 5*m;
				if ( keyboard.pressed("N") )
				thrust = 10*m;
				if ( keyboard.pressed("M") )
				thrust = 15*m;
				return new THREE.Vector3(0, thrust, 0);				  
			}
			
			function calculate_turn(){
				
				var qt = new THREE.Vector3(0, -3, 0);
				qt.applyQuaternion(plane_body.quaternion);
				if ( keyboard.pressed("A") ){
					plane_body.setAngularVelocity(qt);    
				}
				var ql = new THREE.Vector3(0, 3, 0);
				ql.applyQuaternion(plane_body.quaternion);
				if ( keyboard.pressed("D") ){
					plane_body.setAngularVelocity(ql); 
				}
				
				
				
			}
			
			function calculate_pitch(){
				
				var qt = new THREE.Vector3(-1, 0, 0);
				qt.applyQuaternion(plane_body.quaternion);
				if ( keyboard.pressed("W") ){
					plane_body.setAngularVelocity(qt);    
				}
				var ql = new THREE.Vector3(1, 0, 0);
				ql.applyQuaternion(plane_body.quaternion);
				if ( keyboard.pressed("S") ){
					plane_body.setAngularVelocity(ql); 
				}
				
				
				
			}
			function setupGui(){
				myGui ={
					
					lift:0,
					drag: 0,
					thrust:0
					
					
				};
				var gui = new dat.GUI();
				gui.add( myGui, "lift").listen();
				gui.add( myGui, "drag").listen();
				gui.add( myGui, "thrust").listen();
				
			}	
			
			function listen(drag, lift, thrust){
				myGui.drag=drag.x;
				myGui.lift=drag.y;
				myGui.thrust=drag.z;
				
			}
			
		</script>
	</body>
</html>